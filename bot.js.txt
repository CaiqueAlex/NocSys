const wppconnect = require('@wppconnect-team/wppconnect');
const axios = require('axios');

const OPERADOR = '5514997642104@c.us';
const API_BASE_URL = 'http://localhost:80';
const INACTIVITY_TIMEOUT = 900 * 1000;

const conversationState = {};
let specialNumbers = [];

async function fetchSpecialNumbers() {
    try {
        console.log('üîÑ Buscando n√∫meros de clientes...');
        const response = await axios.get(`${API_BASE_URL}/api/clientes/numeros/`);
        specialNumbers = response.data;
        console.log(`‚úÖ N√∫meros de clientes atualizados: ${specialNumbers.length} contatos carregados.`);
    } catch (error) {
        console.error('‚ùå Erro ao buscar n√∫meros de clientes da API:', error.message);
    }
}

function getBaseKey(u1, u2) {
    return [u1, u2].sort().join('|');
}

wppconnect.create({
    session: 'noc-bot',
    catchQR: (base64Qr, asciiQR) => { console.log(asciiQR); },
    statusFind: (statusSession, session) => { console.log('Status:', statusSession, 'Session:', session); },
    headless: false,
    devtools: false,
    useChrome: true,
    debug: false,
    logQR: true,
    browserArgs: ['--no-sandbox'],
    autoClose: 90000,
    puppeteerOptions: {},
    disableWelcome: true,
})
.then(client => start(client))
.catch(console.error);

function resetInactivityTimer(client, contato) {
    const currentState = conversationState[contato];
    if (currentState && currentState.timeoutId) {
        clearTimeout(currentState.timeoutId);
    }
    if (currentState) {
        currentState.timeoutId = setTimeout(async () => {
            if (currentState.stage === 'recording') {
                console.log(`‚è≥ Conversa com ${contato} inativa. Finalizando grava√ß√£o...`);
                await finalizarGravacao(client, contato, true);
                delete conversationState[contato];
            }
        }, INACTIVITY_TIMEOUT);
    }
}

async function start(client) {
    await fetchSpecialNumbers();
    setInterval(fetchSpecialNumbers, 5 * 60 * 1000);
    console.log('‚úÖ Bot iniciado. Aguardando mensagens...');

    client.onAnyMessage(async (msg) => {
        console.log(`\n--- [${new Date().toLocaleString()}] ---`);
        console.log(`üì® Mensagem recebida: De=${msg.from}, Para=${msg.to}, Tipo=${msg.type}`);
        
        try {
            if (msg.isGroupMsg || !msg.from) return;

            const { from, to, type, mimetype, filename } = msg;

            if (type === 'sticker') {
                console.log(`üö´ Figurinha de ${from} ignorada.`);
                return;
            }

            let contato;
            if (from === OPERADOR && to?.endsWith('@c.us')) {
                contato = to;
            } else if (to === OPERADOR && from?.endsWith('@c.us')) {
                contato = from;
            } else {
                return;
            }

            console.log(`üë§ Contato da conversa: ${contato}`);

            if (!conversationState[contato]) {
                conversationState[contato] = { stage: 'start' };
                console.log(`üèÅ Nova conversa iniciada com ${contato}. Estado: 'start'`);
            }
            const currentState = conversationState[contato];
            console.log(`‚ÑπÔ∏è Estado atual da conversa com ${contato}: ${currentState.stage}`);


            if (currentState.stage === 'recording') {
                console.log(`üîÑ Reiniciando timer de inatividade para ${contato}.`);
                resetInactivityTimer(client, contato);
            }

            const texto = (msg.body || '').trim();

            if (from === OPERADOR) {
                console.log('üó£Ô∏è Mensagem do OPERADOR');
                
                if (type === 'chat' && texto.startsWith('/')) {
                    console.log(`‚öôÔ∏è Comando do operador detectado: ${texto}`);
                    if (/^\/\/\/\s*$/.test(texto)) {
                        currentState.stage = currentState.stage === 'manual_override' ? 'start' : 'manual_override';
                        await client.sendText(from, `ü§ñ Fluxo autom√°tico ${currentState.stage === 'manual_override' ? 'PAUSADO' : 'REATIVADO'}.`);
                    } else if (/^\/s$/i.test(texto)) {
                        if (currentState.stage !== 'recording') {
                            currentState.key = `${getBaseKey(OPERADOR, contato)}#${Date.now()}`;
                            currentState.slots = [];
                            currentState.stage = 'recording';
                            resetInactivityTimer(client, contato);
                            await client.sendText(from, 'üü¢ Grava√ß√£o manual ativada.');
                            console.log(`üî¥ Grava√ß√£o iniciada manualmente para ${contato}.`);
                        }
                    } else if (/^\/d$/i.test(texto)) {
                        if (currentState.key) await axios.delete(`${API_BASE_URL}/api/whatsapp-note/clean-by-key/${encodeURIComponent(currentState.key)}/`);
                        delete conversationState[contato];
                        await client.sendText(OPERADOR, 'üóëÔ∏è Conversa/grava√ß√£o cancelada.');
                        console.log(`üóëÔ∏è Grava√ß√£o cancelada para ${contato}.`);
                    }
                    return; 
                }

                if (type === 'chat' && texto.toLowerCase() === 'chamado encerrado!') {
                    console.log(`üèÅ Comando de finaliza√ß√£o de grava√ß√£o para ${contato}`);
                    if (!currentState.key) return client.sendText(from, '‚ö†Ô∏è Nenhuma grava√ß√£o ativa para finalizar.');
                    await finalizarGravacao(client, contato, false);
                    delete conversationState[contato];
                    return;
                }

                if (currentState.stage === 'recording') {
                    console.log('üî¥ Gravando mensagem do OPERADOR...');
                    
                    const payload = {
                        conversation_key: currentState.key,
                        username: from,
                        contact_name: 'Suporte',
                    };
                    
                    let hasContent = false;
                    // *** ALTERA√á√ÉO AQUI: Adicionado 'document' √† lista de tipos de m√≠dia ***
                    if (['image', 'ptt', 'video', 'document'].includes(type)) {
                        hasContent = true;
                        console.log(`üì• Decodificando m√≠dia (operador) tipo '${type}'...`);
                        
                        const buffer = await client.decryptFile(msg);
                        
                        if (buffer) {
                            console.log(`‚úÖ M√≠dia (operador) decodificada com sucesso (${(buffer.length / 1024).toFixed(2)} KB).`);
                            payload.media_data = `data:${mimetype};base64,${buffer.toString('base64')}`;
                            // Para documentos, o nome do arquivo vai no 'text'
                            payload.text = (type === 'document') ? filename : (msg.caption || '');
                            payload.msg_type = (type === 'ptt') ? 'audio' : type;
                        } else {
                            hasContent = false;
                            console.error(`‚ùå Falha ao decodificar m√≠dia (operador) de ${from}.`);
                        }
                    } else if (texto) {
                        hasContent = true;
                        payload.text = texto;
                        payload.msg_type = 'text';
                    }

                    if (hasContent) {
                        console.log(`üì§ Enviando payload (operador) para API. Tipo: ${payload.msg_type}`);
                        const { data } = await axios.post(`${API_BASE_URL}/api/whatsapp-note/`, payload);
                        currentState.slots.push(data.id);
                        console.log(`‚úÖ Payload (operador) salvo. ID do Slot: ${data.id}`);
                    } else {
                         console.log(`ü§∑ Nenhuma a√ß√£o de grava√ß√£o para esta mensagem (operador).`);
                    }
                    return; 
                }
            }

            if (currentState.stage === 'manual_override') {
                console.log(`‚è∏Ô∏è Fluxo autom√°tico para ${contato} est√° pausado. Ignorando mensagem do cliente.`);
                return;
            }

            if (from === contato) {
                console.log('üë§ Mensagem do CLIENTE');
                if (currentState.stage === 'start' && specialNumbers.includes(from)) {
                    currentState.stage = 'awaiting_menu_choice';
                    console.log(`üì≤ Enviando menu para cliente especial ${contato}.`);
                    await client.sendText(contato, 'Ol√°! Como posso ajudar?\n\n*Digite:*\n*1* para Abrir um Chamado\n*2* para Outros Assuntos');
                } else if (currentState.stage === 'awaiting_menu_choice') {
                    if (texto === '1') {
                        currentState.key = `${getBaseKey(OPERADOR, contato)}#${Date.now()}`;
                        currentState.slots = [];
                        currentState.stage = 'awaiting_problem';
                        console.log(`üî¥ Cliente ${contato} escolheu abrir chamado. Aguardando descri√ß√£o.`);
                        await client.sendText(contato, 'Certo! Para abrir seu chamado, por favor, descreva o problema ou envie fotos, v√≠deos e √°udios.');
                    } else {
                        console.log(`üëã Cliente ${contato} escolheu outra op√ß√£o. Encerrando fluxo.`);
                        delete conversationState[contato];
                        await client.sendText(contato, 'Ok. Se precisar de algo, √© s√≥ chamar.');
                    }
                } else if (currentState.stage === 'awaiting_problem' || currentState.stage === 'recording') {
                    const isFirstMessage = currentState.stage === 'awaiting_problem';
                    const contactInfo = await client.getContact(from);
                    const contactDisplayName = contactInfo.name || contactInfo.pushname || from;
                    
                    console.log(`üî¥ Gravando mensagem do CLIENTE (${contactDisplayName})...`);
                    const payload = {
                        conversation_key: currentState.key,
                        username: from,
                        contact_name: contactDisplayName,
                    };
                    
                    let hasContent = false;
                    // *** ALTERA√á√ÉO AQUI: Adicionado 'document' √† lista de tipos de m√≠dia ***
                    if (['image', 'ptt', 'video', 'document'].includes(type)) {
                        hasContent = true;
                        console.log(`üì• Decodificando m√≠dia (cliente) tipo '${type}'...`);
                        
                        const buffer = await client.decryptFile(msg);
                        
                        if (buffer) {
                            console.log(`‚úÖ M√≠dia (cliente) decodificada com sucesso (${(buffer.length / 1024).toFixed(2)} KB).`);
                            payload.media_data = `data:${mimetype};base64,${buffer.toString('base64')}`;
                            payload.text = (type === 'document') ? filename : (msg.caption || '');
                            payload.msg_type = (type === 'ptt') ? 'audio' : type;
                            if (isFirstMessage) payload.problema = msg.caption || `[M√≠dia: ${payload.msg_type}]`;
                        } else {
                            hasContent = false;
                            console.error(`‚ùå Falha ao decodificar m√≠dia (cliente) de ${from}.`);
                        }
                    } else if (texto) {
                        hasContent = true;
                        payload.text = texto;
                        payload.msg_type = 'text';
                        if (isFirstMessage) payload.problema = texto;
                    }

                    if (hasContent) {
                        console.log(`üì§ Enviando payload (cliente) para API. Tipo: ${payload.msg_type}`);
                        const { data } = await axios.post(`${API_BASE_URL}/api/whatsapp-note/`, payload);
                        currentState.slots.push(data.id);
                        console.log(`‚úÖ Payload (cliente) salvo. ID: ${data.id}`);

                        if (isFirstMessage) {
                            currentState.stage = 'recording';
                            console.log(`üîî Chamado aberto por ${contactDisplayName}. Notificando operador.`);
                            await client.sendText(contato, '*‚úÖ Obrigado! Sua solicita√ß√£o foi registrada com sucesso.*\nPara que possamos entender melhor e resolver seu problema, por favor, envie mais detalhes usando mensagens, fotos ou √°udios ‚Äî incluindo, se poss√≠vel, o caminho ou passo a passo onde a situa√ß√£o ocorreu. Agora √© s√≥ aguardar o contato de um atendente do suporte.');
                            await client.sendText(OPERADOR, `üîî Novo chamado aberto por ${contactDisplayName}.`);
                        }
                    } else {
                        console.log(`ü§∑ Nenhuma a√ß√£o de grava√ß√£o para a mensagem do cliente.`);
                    }
                }
            }
        } catch (err) {
            const errorMessage = err.response ? JSON.stringify(err.response.data) : (err.message || 'Erro desconhecido');
            console.error('‚ùå Erro no processamento da mensagem: ', errorMessage, err.stack);
            if (client) await client.sendText(OPERADOR, `‚ùå Erro no Bot: ${err.message || 'Erro desconhecido'}`);
        }
    });
}

async function finalizarGravacao(client, contato, isAutomatic = false) {
    const state = conversationState[contato];
    if (!state || !state.key || !state.slots || state.slots.length === 0) {
        if (!isAutomatic) await client.sendText(OPERADOR, '‚ö†Ô∏è Nenhuma mensagem para registrar.');
        return;
    }
    
    if (state.timeoutId) clearTimeout(state.timeoutId);

    try {
        console.log(`üì¶ Finalizando grava√ß√£o para ${contato}. O chamado ser√° criado como ABERTO. C√≥digo ser√° gerado.`);
        const { data } = await axios.get(`${API_BASE_URL}/api/get-next-codigo/`);
        const codigo = data.codigo;
        console.log(`üè∑Ô∏è C√≥digo do chamado gerado: #${codigo}`);

        for (const slotId of state.slots) {
            await axios.patch(`${API_BASE_URL}/api/whatsapp-note/${slotId}/`, {
                chamadofinalizado: false, 
                codigo_chamado: codigo
            });
        }
        
        const msg = `üü° Grava√ß√£o de conversa encerrada! C√≥digo do Chamado: #${codigo}`;
        await client.sendText(OPERADOR, msg);
        if (isAutomatic) await client.sendText(OPERADOR, `(A grava√ß√£o foi encerrada automaticamente por inatividade)`);
        console.log(`‚úÖ Grava√ß√£o para o chamado #${codigo} finalizada e salva como ABERTO.`);

    } catch (err) {
        const errorMessage = err.response ? JSON.stringify(err.response.data) : (err.message || 'Erro desconhecido');
        console.error('‚ùå Erro ao finalizar grava√ß√£o: ', errorMessage);
        await client.sendText(OPERADOR, `‚ùå Erro ao finalizar grava√ß√£o: ${err.message}`);
    }
}